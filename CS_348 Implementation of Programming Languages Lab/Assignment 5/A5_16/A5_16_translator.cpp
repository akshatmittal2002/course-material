#include "A5_16_translator.h"
#include <bits/stdc++.h>
using namespace std;

// Global variables for translator
SymTab* ST;
int nextinstr = 0;
SymTab globalST;
QuadArr quadList;
int SymTab::tempCount = 0;

// Implementations of constructors and functions for the Sym class
Sym::Sym() {
    nestedTable = NULL;
}

// Implementations of constructors and functions for the SymVal class
void SymVal::SetInit(char val) {
    c = val;
    i = val;
    p = NULL;
}

void SymVal::SetInit(int val) {
    c = val;
    i = val;
    p = NULL;
}

// Implementations of constructors and functions for the SymTab class
SymTab::SymTab() {
    offset = 0;
}

Sym* SymTab::SearchGlob(string name) {
    if(table.count(name)) {
        return table[name];
    }
    else {
        return NULL;
    }
}

Sym* SymTab::Lookup(string name, DataType t, int pc) {
    if(table.count(name) != 0);
    else {
        Sym* sym = new Sym();
        sym->initVal = NULL;
        sym->type.type = t;
        sym->name = name;
        sym->offset = offset;

        if(pc != 0) {
            sym->type.type = ARRAY;
            sym->type.nextType = t;
            sym->size = __POINTER_SIZE;
            sym->type.pointers = pc;
        }
        else {
            sym->size = TypeSize(t);
            offset += sym->size;
        }
        table[name] = sym;
        symbols.push_back(sym);
    }
    return table[name];
}

void SymTab::print(string tableName) {
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";
    cout << "Symbol Table: " << setfill(' ') << left << setw(50) << tableName << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // Table Headers
    cout << setfill(' ') << left << setw(20) <<  "Name";
    cout << left << setw(10) << "Size";
    cout << left << setw(15) << "Type";
    cout << left << setw(10) << "Offset";
    cout << left << setw(15) << "Initial Value";
    cout << left << "Nested" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // For storing nested Sym tables
    vector<pair<string, SymTab*>> tableList;

    // Print the symbols in the Sym table
    int ii = 0;
    while(1) {
        if(ii >= (int)symbols.size()) break;
        Sym* sym = symbols[ii];
        cout << left << setw(20) << sym->name;
        cout << left << setw(10) << sym->size;
        cout << left << setw(15) << TypeCheck(sym->type);
        cout << left << setw(10) << sym->offset;
        cout << left << setw(15) << GetInit(sym);
        cout << left;

        if(sym->nestedTable == NULL) {
            cout << "NULL" << "\n";
        }
        else {
            tableList.push_back({tableName + "." + sym->name, sym->nestedTable});
            cout << tableName + "." + sym->name << "\n";
        }
        ii++;
    }

    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n" << "\n";

    // Recursively call the print function for the nested Sym tables
    auto it = tableList.begin();
    while(1) {
        if(it == tableList.end()) break;
        auto p = (*it);
        p.second->print(p.first);
        it++;
    }

}

string SymTab::GenerateTemp(DataType t) {
    // Create the name for the temporary
    string tempName = "t";
    tempName += to_string(SymTab::tempCount);
    tempCount++;
    
    // Initialize the required attributes
    Sym* sym = new Sym();
    sym->initVal = NULL;
    sym->size = TypeSize(t);
    sym->name = tempName;
    sym->type.type = t;
    sym->offset = offset;

    offset += sym->size;
    table[tempName] = sym;  // Add the temporary to the Sym table
    symbols.push_back(sym);

    return tempName;
}

// Implementations of constructors and functions for the QuadArr class
void QuadArr::print() {
    cout << "Generated By Group 16" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";
    cout << "THREE ADDRESS CODE (TAC):" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // Print each of the quads one by one
    int ii = 0;
    while(1) {
        if(ii >= quads.size()) break;
        if(!(quads[ii].op == FUNC_BEG || quads[ii].op == FUNC_END))
            cout << left << setw(4) << ii << ":    ";
        else if(quads[ii].op == FUNC_END)
            cout << left << setw(4) << ii << ": ";
        else if(quads[ii].op == FUNC_BEG)
            cout << "\n" << left << setw(4) << ii << ": ";
        cout << quads[ii].print() << "\n";
        ii++;
    }
    cout << "\n";
}

// Implementations of constructors and functions for the Quad class
Quad::Quad(string res_, string arg1_, string arg2_, opcode op_) {
    op = op_;
    arg1 = arg1_;
    arg2 = arg2_;
    result = res_;
}

// Implementations of constructors and functions for the Expression class
Expression::Expression() {
    fold = 0;
    folder = NULL;
}

// Implementations of constructors and functions for the Quad class
string Quad::print() {
    string out = "";
    if(op >= U_PLUS && op <= LOG_NOT) {        // Unary operators
        out += (result + " = ");
        switch(op) {
            case LOG_NOT: out += "!"; break;
            case DEREFERENCE: out += "*"; break;
            case U_MINUS: out += "-"; break;
            case U_PLUS: out += "+"; break;
            case REFERENCE: out += "&"; break;
        }
        out += arg1;
    }
    else if(op >= ADD && op <= SR) {                 // Binary operators
        out += (result + " = " + arg1 + " ");
        switch(op) {
            case SR: out += ">>"; break;
            case DIV: out += "/"; break;
            case SL: out += "<<"; break;
            case SUB: out += "-"; break;
            case MOD: out += "%"; break;
            case MULT: out += "*"; break;
            case ADD: out += "+"; break;
        }
        out += (" " + arg2);
    }
    else if(op >= CtoI && op <= ItoC) {             // Type Conversion functions
        out += (result + " = ");
        switch(op) {
            case ItoC: out += "IntToChar"; break;
            case CtoI: out += "CharToInt"; break;
        }
        out += ("(" + arg1 + ")");
    }
    else if(op >= GOTO_EQ && op <= IF_FALSE_GOTO) { // Conditional operators
        out += ("if " + arg1 + " ");
        switch(op) {
            case IF_FALSE_GOTO: out += "== 0"; break;
            case GOTO_EQ: out += "=="; break;
            case GOTO_GT: out += ">"; break;
            case GOTO_LT: out += "<"; break;
            case IF_GOTO: out += "!= 0"; break;
            case GOTO_LTE: out += "<="; break;
            case GOTO_GTE: out += ">="; break;
            case GOTO_NEQ: out += "!="; break;
        }
        out += (" " + arg2 + " goto " + result);
    }
    else if(op == CALL) {                       // Call a function
        if(arg2.size() > 0)
            out += (arg2 + " = ");
        out += ("call " + result + ", " + arg1);
    }
    else if(op == FUNC_BEG)                     // Function begin
        out += (result + ": ");
    else if(op == PARAM)                        // Parameters for a function
        out += ("param " + result);
    else if(op == GOTO)                         // Goto
        out += ("goto " + result);
    else if(op == ARR_IDX_ARG)                  // Array indexing
        out += (result + " = " + arg1 + "[" + arg2 + "]");
    else if(op == ASSIGN)                       // Assignment operator
        out += (result + " = " + arg1);
    else if(op == ARR_IDX_RES)                  // Array indexing
        out += (result + "[" + arg2 + "] = " + arg1);
    else if(op == RETURN)                       // Return from a function
        out += ("return " + result);
    else if(op == L_DEREF)                      // Dereference
        out += ("*" + result + " = " + arg1);
    else if(op == FUNC_END)                     // Function end
        out += (result + " ends");

    return out;
}

// Implementation of the merge function
list<int> merge(list<int> list1, list<int> list2) {
    list1.merge(list2);
    return list1;
}

// Implementation of the backpatch function
void backpatch(list<int> l, int address) {
    string str = to_string(address);
    auto it = l.begin();
    while(1) {
        if(it == l.end()) break;
        quadList.quads[*it].result = str;
        it++;
    }
}

// Implementation of the makelist function
list<int> makelist(int i) {
    list<int> l(1, i);
    return l;
}

// Overloaded emit functions
void emit(string result, char constant, opcode op) {
    nextinstr++;
    Quad q(result, to_string(constant), "", op);
    quadList.quads.push_back(q);
}

void emit(string result, int constant, opcode op) {
    nextinstr++;
    Quad q(result, to_string(constant), "", op);
    quadList.quads.push_back(q);
}

void emit(string result, string arg1, string arg2, opcode op) {
    nextinstr++;
    Quad q(result, arg1, arg2, op);
    quadList.quads.push_back(q);
}

// Implementation of the ConvertTo function
void ConvertTo(string t, DataType to, string f, DataType from) {
    if(to != from) {
        if(from == CHAR && to == INT)
            emit(t, f, "", CtoI);
        else if(from == INT && to == CHAR)
            emit(t, f, "", ItoC);
    }
}

// Implementation of the IntToBool function
void IntToBool(Expression* expr) {
    if(expr->type == BOOL)
        return;
    expr->type = BOOL;
    expr->falselist = makelist(nextinstr);    // Add falselist for boolean expressions
    emit("", expr->loc, "", IF_FALSE_GOTO);
    expr->truelist = makelist(nextinstr);     // Add truelist for boolean expressions
    emit("", "", "", GOTO);
}

// Implementation of the ConvertTo function
void ConvertTo(Expression* arg, Expression* res, DataType toType) {
    if(res->type != toType) {
        if(res->type == CHAR && toType == INT)
            emit(arg->loc, res->loc, "", CtoI);
        else if(res->type == INT && toType == CHAR)
            emit(arg->loc, res->loc, "", ItoC);
    }
}

// Implementation of the GetInit function
string GetInit(Sym* sym) {
    if(sym->initVal == NULL)
        return "-";
    else {
        switch (sym->type.type){
            case CHAR: return to_string(sym->initVal->c);
            case INT: return to_string(sym->initVal->i);
            default: return "-";
        }
    }
}

// Implementation of the TypeSize function
int TypeSize(DataType t) {
    switch(t){
        case VOID: return __VOID_SIZE;
        case FUNCTION: return __FUNCTION_SIZE;
        case CHAR: return __CHARACTER_SIZE;
        case POINTER: return __POINTER_SIZE;
        case INT: return __INTEGER_SIZE;
        default: return 0;
    }
}

// Implementation of the TypeCheck function
string TypeCheck(SymType t) {
    switch(t.type){
        case ARRAY: {
            string tp = "";
            if(t.nextType == INT)
                tp += "int";
            else if(t.nextType == CHAR)
                tp += "char";
            for(int i = 0; i < t.dims.size(); i++) {
                if(t.dims[i] == 0)
                    tp += "[]";
                else
                    tp += "[" + to_string(t.dims[i]) + "]";
            }
            return tp + ((t.dims.size() == 0) ? "[]" : "");
        }
        case VOID: return "void";
        case FUNCTION: return "function";
        case INT: return "int";
        case POINTER: {
            string tp = "";
            if(t.nextType == INT)
                tp += "int";
            else if(t.nextType == CHAR)
                tp += "char";
            return tp + string(t.pointers, '*');
        }
        case CHAR: return "char";
        default: return "unknown";
    }
}

int main(int argc, char* argv[]) {
    ST = &globalST;
    yyparse();
    quadList.print();               // Print the three address quads
    ST->print("ST.global");         // Print the Sym tables

    return 0;
}