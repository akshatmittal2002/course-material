#include "A6_16_translator.h"
#include <bits/stdc++.h>
using namespace std;

// Global variables for translator
SymTab* ST;
int nextinstr = 0;
SymTab globalST;
QuadArr quadList;
int SymTab::tempCount = 0;

// Implementations of constructors and functions for the Sym class
Sym::Sym() {
    nestedTable = NULL;
}

// Implementations of constructors and functions for the SymVal class
void SymVal::SetInit(char val) {
    c = val;
    i = val;
    p = NULL;
}

void SymVal::SetInit(int val) {
    c = val;
    i = val;
    p = NULL;
}

// Implementations of constructors and functions for the SymTab class
SymTab::SymTab() {
    offset = 0;
}

Sym* SymTab::SearchGlob(string name) {
    if(table.count(name)) {
        return table[name];
    }
    else {
        return NULL;
    }
}

Sym* SymTab::Lookup(string name, DataType t, int pc) {
    if(table.count(name) != 0);
    else {
        Sym* sym = new Sym();
        sym->initVal = NULL;
        sym->type.type = t;
        sym->name = name;
        sym->offset = offset;

        if(pc != 0) {
            sym->type.type = ARRAY;
            sym->type.nextType = t;
            sym->size = __POINTER_SIZE;
            sym->type.pointers = pc;
        }
        else {
            sym->size = TypeSize(t);
            offset += sym->size;
        }
        table[name] = sym;
        symbols.push_back(sym);
    }
    return table[name];
}

void SymTab::print(string tableName) {
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";
    cout << "Symbol Table: " << setfill(' ') << left << setw(50) << tableName << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // Table Headers
    cout << setfill(' ') << left << setw(20) <<  "Name";
    cout << left << setw(10) << "Size";
    cout << left << setw(15) << "Type";
    cout << left << setw(10) << "Offset";
    cout << left << setw(15) << "Initial Value";
    cout << left << "Nested" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // For storing nested Sym tables
    vector<pair<string, SymTab*>> tableList;

    // Print the symbols in the Sym table
    int ii = 0;
    while(1) {
        if(ii >= (int)symbols.size()) break;
        Sym* sym = symbols[ii];
        cout << left << setw(20) << sym->name;
        cout << left << setw(10) << sym->size;
        cout << left << setw(15) << TypeCheck(sym->type);
        cout << left << setw(10) << sym->offset;
        cout << left << setw(15) << GetInit(sym);
        cout << left;

        if(sym->nestedTable == NULL) {
            cout << "NULL" << "\n";
        }
        else {
            tableList.push_back({tableName + "." + sym->name, sym->nestedTable});
            cout << tableName + "." + sym->name << "\n";
        }
        ii++;
    }

    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n" << "\n";

    // Recursively call the print function for the nested Sym tables
    auto it = tableList.begin();
    while(1) {
        if(it == tableList.end()) break;
        auto p = (*it);
        p.second->print(p.first);
        it++;
    }

}

string SymTab::GenerateTemp(DataType t) {
    // Create the name for the temporary
    string tempName = "t";
    tempName += to_string(SymTab::tempCount);
    tempCount++;
    
    // Initialize the required attributes
    Sym* sym = new Sym();
    sym->initVal = NULL;
    sym->size = TypeSize(t);
    sym->name = tempName;
    sym->type.type = t;
    sym->offset = offset;

    offset += sym->size;
    table[tempName] = sym;  // Add the temporary to the Sym table
    symbols.push_back(sym);

    return tempName;
}

// Implementations of constructors and functions for the QuadArr class
void QuadArr::print() {
    cout << "Generated By Group 16" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";
    cout << "THREE ADDRESS CODE (TAC):" << "\n";
    for(int i = 120; i > 0; i--) {
        cout << '-';
    }
    cout << "\n";

    // Print each of the quads one by one
    int ii = 0;
    while(1) {
        if(ii >= quads.size()) break;
        if(!(quads[ii].op == FUNC_BEG || quads[ii].op == FUNC_END))
            cout << left << setw(4) << ii << ":    ";
        else if(quads[ii].op == FUNC_END)
            cout << left << setw(4) << ii << ": ";
        else if(quads[ii].op == FUNC_BEG)
            cout << "\n" << left << setw(4) << ii << ": ";
        cout << quads[ii].print() << "\n";
        ii++;
    }
    cout << "\n";
}

// Implementations of constructors and functions for the Quad class
Quad::Quad(string res_, string arg1_, string arg2_, opcode op_) {
    op = op_;
    arg1 = arg1_;
    arg2 = arg2_;
    result = res_;
}

// Implementations of constructors and functions for the Expression class
Expression::Expression() {
    fold = 0;
    folder = NULL;
}

// Implementations of constructors and functions for the Quad class
string Quad::print() {
    string out = "";
    if(op >= U_PLUS && op <= LOG_NOT) {        // Unary operators
        out += (result + " = ");
        switch(op) {
            case LOG_NOT: out += "!"; break;
            case DEREFERENCE: out += "*"; break;
            case U_MINUS: out += "-"; break;
            case U_PLUS: out += "+"; break;
            case REFERENCE: out += "&"; break;
        }
        out += arg1;
    }
    else if(op >= ADD && op <= SR) {                 // Binary operators
        out += (result + " = " + arg1 + " ");
        switch(op) {
            case SR: out += ">>"; break;
            case DIV: out += "/"; break;
            case SL: out += "<<"; break;
            case SUB: out += "-"; break;
            case MOD: out += "%"; break;
            case MULT: out += "*"; break;
            case ADD: out += "+"; break;
        }
        out += (" " + arg2);
    }
    else if(op >= CtoI && op <= ItoC) {             // Type Conversion functions
        out += (result + " = ");
        switch(op) {
            case ItoC: out += "IntToChar"; break;
            case CtoI: out += "CharToInt"; break;
        }
        out += ("(" + arg1 + ")");
    }
    else if(op >= GOTO_EQ && op <= IF_FALSE_GOTO) { // Conditional operators
        out += ("if " + arg1 + " ");
        switch(op) {
            case IF_FALSE_GOTO: out += "== 0"; break;
            case GOTO_EQ: out += "=="; break;
            case GOTO_GT: out += ">"; break;
            case GOTO_LT: out += "<"; break;
            case IF_GOTO: out += "!= 0"; break;
            case GOTO_LTE: out += "<="; break;
            case GOTO_GTE: out += ">="; break;
            case GOTO_NEQ: out += "!="; break;
        }
        out += (" " + arg2 + " goto " + result);
    }
    else if(op == CALL) {                       // Call a function
        if(arg2.size() > 0)
            out += (arg2 + " = ");
        out += ("call " + result + ", " + arg1);
    }
    else if(op == FUNC_BEG)                     // Function begin
        out += (result + ": ");
    else if(op == PARAM)                        // Parameters for a function
        out += ("param " + result);
    else if(op == GOTO)                         // Goto
        out += ("goto " + result);
    else if(op == ARR_IDX_ARG)                  // Array indexing
        out += (result + " = " + arg1 + "[" + arg2 + "]");
    else if(op == ASSIGN)                       // Assignment operator
        out += (result + " = " + arg1);
    else if(op == ARR_IDX_RES)                  // Array indexing
        out += (result + "[" + arg2 + "] = " + arg1);
    else if(op == RETURN)                       // Return from a function
        out += ("return " + result);
    else if(op == L_DEREF)                      // Dereference
        out += ("*" + result + " = " + arg1);
    else if(op == FUNC_END)                     // Function end
        out += (result + " ends");

    return out;
}

// Implementation of the merge function
list<int> merge(list<int> list1, list<int> list2) {
    list1.merge(list2);
    return list1;
}

// Implementation of the backpatch function
void backpatch(list<int> l, int address) {
    string str = to_string(address);
    auto it = l.begin();
    while(1) {
        if(it == l.end()) break;
        quadList.quads[*it].result = str;
        it++;
    }
}

// Implementation of the makelist function
list<int> makelist(int i) {
    list<int> l(1, i);
    return l;
}

// Overloaded emit functions
void emit(string result, char constant, opcode op) {
    nextinstr++;
    Quad q(result, to_string(constant), "", op);
    quadList.quads.push_back(q);
}

void emit(string result, int constant, opcode op) {
    nextinstr++;
    Quad q(result, to_string(constant), "", op);
    quadList.quads.push_back(q);
}

void emit(string result, string arg1, string arg2, opcode op) {
    nextinstr++;
    Quad q(result, arg1, arg2, op);
    quadList.quads.push_back(q);
}

// Implementation of the ConvertTo function
void ConvertTo(string t, DataType to, string f, DataType from) {
    if(to != from) {
        if(from == CHAR && to == INT)
            emit(t, f, "", CtoI);
        else if(from == INT && to == CHAR)
            emit(t, f, "", ItoC);
    }
}

// Implementation of the IntToBool function
void IntToBool(Expression* expr) {
    if(expr->type == BOOL)
        return;
    expr->type = BOOL;
    expr->falselist = makelist(nextinstr);    // Add falselist for boolean expressions
    emit("", expr->loc, "", IF_FALSE_GOTO);
    expr->truelist = makelist(nextinstr);     // Add truelist for boolean expressions
    emit("", "", "", GOTO);
}

// Implementation of the ConvertTo function
void ConvertTo(Expression* arg, Expression* res, DataType toType) {
    if(res->type != toType) {
        if(res->type == CHAR && toType == INT)
            emit(arg->loc, res->loc, "", CtoI);
        else if(res->type == INT && toType == CHAR)
            emit(arg->loc, res->loc, "", ItoC);
    }
}

// Implementation of the GetInit function
string GetInit(Sym* sym) {
    if(sym->initVal == NULL)
        return "-";
    else {
        switch (sym->type.type){
            case CHAR: return to_string(sym->initVal->c);
            case INT: return to_string(sym->initVal->i);
            default: return "-";
        }
    }
}

// Implementation of the TypeSize function
int TypeSize(DataType t) {
    switch(t){
        case VOID: return __VOID_SIZE;
        case FUNCTION: return __FUNCTION_SIZE;
        case CHAR: return __CHARACTER_SIZE;
        case POINTER: return __POINTER_SIZE;
        case INT: return __INTEGER_SIZE;
        default: return 0;
    }
}

// Implementation of the TypeCheck function
string TypeCheck(SymType t) {
    switch(t.type){
        case ARRAY: {
            string tp = "";
            if(t.nextType == INT)
                tp += "int";
            else if(t.nextType == CHAR)
                tp += "char";
            for(int i = 0; i < t.dims.size(); i++) {
                if(t.dims[i] == 0)
                    tp += "[]";
                else
                    tp += "[" + to_string(t.dims[i]) + "]";
            }
            return tp + ((t.dims.size() == 0) ? "[]" : "");
        }
        case VOID: return "void";
        case FUNCTION: return "function";
        case INT: return "int";
        case POINTER: {
            string tp = "";
            if(t.nextType == INT)
                tp += "int";
            else if(t.nextType == CHAR)
                tp += "char";
            return tp + string(t.pointers, '*');
        }
        case CHAR: return "char";
        default: return "unknown";
    }
}

// ======================================= Target Translator =======================================//
// Global variables for target translator
vector<string> stringConsts;
map<int, string> labels;
stack<pair<string, int>> parameters;
int labelCount = 0;
string funcRunning = "";

// Generates assembly code for a given three address Quad
void quadCode(Quad q, ofstream& sfile) {
    string strLabel = q.result;
    bool hasStrLabel = !(q.result[0] != '.' || q.result[1] != 'L' || q.result[2] != 'C');
    string toPrint1 = "";
    int off1 = 0;
    string toPrint2 = "";
    int off2 = 0;
    string toPrintRes = "";
    int offRes = 0;

    Sym* glb3 = globalST.SearchGlob(q.result);
    Sym* loc1 = ST->Lookup(q.arg1);
    Sym* glb2 = globalST.SearchGlob(q.arg2);
    Sym* loc2 = ST->Lookup(q.arg2);
    Sym* glb1 = globalST.SearchGlob(q.arg1);
    Sym* loc3 = ST->Lookup(q.result);

    if(ST == &globalST) {
        toPrint2 = q.arg2;
        toPrintRes = q.result;
        toPrint1 = q.arg1;
    }
    else {
        if(glb3 != NULL);
        else offRes = loc3->offset;
        if(glb1 != NULL);
        else off1 = loc1->offset;
        if(glb2 != NULL);
        else off2 = loc2->offset;

        if(q.arg1[0] >= '0' && q.arg1[0] <= '9');
        else {
            if(glb1 == NULL)
                toPrint1 = to_string(off1) + "(%rbp)";
            else
                toPrint1 = q.arg1 + "(%rip)";
        }
        if(q.arg2[0] >= '0' && q.arg2[0] <= '9');
        else {
            if(glb2 == NULL)
                toPrint2 = to_string(off2) + "(%rbp)";
            else
                toPrint2 = q.arg2 + "(%rip)";
        }
        if(q.result[0] >= '0' && q.result[0] <= '9');
        else {
            if(glb3 == NULL)
                toPrintRes = to_string(offRes) + "(%rbp)";
            else
                toPrintRes = q.result + "(%rip)";
        }
    }

    if(!hasStrLabel);
    else toPrintRes = strLabel;

    if(q.op == ASSIGN) {
        if(q.result[0] != 't' || loc3->type.type == INT || loc3->type.type == POINTER) {
            if(loc3->type.type != POINTER) {
                if(q.arg1[0] < '0' || q.arg1[0] > '9') {
                    sfile << "\tmovl\t";
                    sfile << toPrint1 << ", %eax" << "\n";
                    sfile << "\tmovl\t%eax, ";
                    sfile << toPrintRes << "\n"; 
                }
                else {
                    sfile << "\tmovl\t$";
                    sfile << q.arg1 << ", ";
                    sfile << toPrintRes << "\n";
                }
            }
            else {
                sfile << "\tmovq\t";
                sfile << toPrint1 << ", %rax" << "\n";
                sfile << "\tmovq\t%rax, ";
                sfile << toPrintRes << "\n"; 
            }
        }
        else {
            int temp = q.arg1[0];
            sfile << "\tmovb\t$";
            sfile << temp << ", ";
            sfile << toPrintRes << "\n";
        }
    }
    else if(q.op == U_MINUS) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tnegl\t%eax" << "\n";
        sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == ADD) {
        if(q.arg1[0] > '0' && q.arg1[0] <= '9'){ 
            sfile << "\tmovl\t$";
            sfile << q.arg1 << ", %eax" << "\n";
        }
        else{
            sfile << "\tmovl\t";
            sfile << toPrint1 << ", %eax" << "\n"; 
        }
        if(q.arg2[0] > '0' && q.arg2[0] <= '9'){
            sfile << "\tmovl\t$";
            sfile << q.arg2 << ", %edx" << "\n";
        }
        else{
            sfile << "\tmovl\t";
            sfile << toPrint2 << ", %edx" << "\n"; 
        }
        sfile << "\taddl\t%edx, %eax" << "\n";
        sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == SUB) {
        if(q.arg1[0] > '0' && q.arg1[0] <= '9') {
            sfile << "\tmovl\t$";
            sfile << q.arg1 << ", %edx" << "\n";
        }
        else {
            sfile << "\tmovl\t";
            sfile << toPrint1 << ", %edx" << "\n"; 
        }
        if(q.arg2[0]>'0' && q.arg2[0]<='9') {
            sfile << "\tmovl\t$";
            sfile << q.arg2 << ", %eax" << "\n";
        }
        else {
            sfile << "\tmovl\t";
            sfile << toPrint2 << ", %eax" << "\n";
        }
        sfile << "\tsubl\t%eax, %edx" << "\n";
        sfile << "\tmovl\t%edx, %eax" << "\n";
        sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == MULT) {
        if(q.arg1[0] > '0' && q.arg1[0] <= '9') {
            sfile << "\tmovl\t$";
        sfile << q.arg1 << ", %eax" << "\n";
        }
        else {
            sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        }
        sfile << "\timull\t";
        if(q.arg2[0] > '0' && q.arg2[0] <= '9') {
            sfile << "$";
        sfile << q.arg2 << ", %eax" << "\n";
        }
        else {
            sfile << toPrint2 << ", %eax" << "\n";
        }
        sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == DIV) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcltd\n\tidivl\t";
        sfile << toPrint2 << "\n";
        sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == MOD) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcltd\n\tidivl\t";
        sfile << toPrint2 << "\n";
        sfile << "\tmovl\t%edx, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == GOTO) {
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
    }
    else if(q.op == GOTO_LT) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tjge\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_GT) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tjle\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_GTE) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tjl\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_LTE) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tjg\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_GTE) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tjl\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_EQ) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        if(q.arg2[0] >= '0' && q.arg2[0] <= '9') {
            sfile << "\tcmpl\t$";
        sfile << q.arg2 << ", %eax" << "\n";
        }
        else {
            sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        }
        sfile << "\tjne\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == GOTO_NEQ) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t";
        sfile << toPrint2 << ", %eax" << "\n";
        sfile << "\tje\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == IF_GOTO) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t$0";
        sfile << ", %eax" << "\n";
        sfile << "\tje\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == IF_FALSE_GOTO) {
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tcmpl\t$0";
        sfile << ", %eax" << "\n";
        sfile << "\tjne\t.L";
        sfile << labelCount << "\n";
        sfile << "\tjmp\t";
        sfile << q.result << "\n";
        sfile << ".L";
        sfile << labelCount++ << ":" << "\n";
    }
    else if(q.op == ARR_IDX_ARG) {
        sfile << "\tmovl\t";
        sfile << toPrint2 << ", %edx" << "\n";
        sfile << "cltq" << "\n";
        if(off1 < 0) {
            sfile << "\tmovl\t";
        sfile << off1 << "(%rbp,%rdx,1), %eax" << "\n";
            sfile << "\tmovl\t%eax, ";
        sfile << toPrintRes << "\n";
        }
        else {
            sfile << "\tmovq\t";
        sfile << off1 << "(%rbp), %rdi" << "\n";
            sfile << "\taddq\t%rdi, %rdx" << "\n";
            sfile << "\tmovq\t(%rdx) ,%rax" << "\n";
            sfile << "\tmovq\t%rax, ";
        sfile << toPrintRes << "\n";
        }
    }
    else if(q.op == ARR_IDX_RES) {
        sfile << "\tmovl\t";
        sfile << toPrint2 << ", %edx" << "\n";
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "cltq" << "\n";
        if(offRes > 0) {
            sfile << "\tmovq\t";
            sfile << offRes << "(%rbp), %rdi" << "\n";
            sfile << "\taddq\t%rdi, %rdx" << "\n";
            sfile << "\tmovl\t%eax, (%rdx)" << "\n";
        }
        else {
            sfile << "\tmovl\t%eax, ";
            sfile << offRes << "(%rbp,%rdx,1)" << "\n";
        }
    }
    else if(q.op == REFERENCE) {
        if(off1 < 0) {
            sfile << "\tleaq\t";
        sfile << toPrint1 << ", %rax" << "\n";
            sfile << "\tmovq\t%rax, ";
        sfile << toPrintRes << "\n";
        }
        else {
            sfile << "\tmovq\t";
        sfile << toPrint1 << ", %rax" << "\n";
            sfile << "\tmovq\t%rax, ";
        sfile << toPrintRes << "\n";
        }
    }
    else if(q.op == DEREFERENCE) {
        sfile << "\tmovq\t";
        sfile << toPrint1 << ", %rax" << "\n";
        sfile << "\tmovq\t(%rax), %rdx" << "\n";
        sfile << "\tmovq\t%rdx, ";
        sfile << toPrintRes << "\n";
    }
    else if(q.op == L_DEREF) {
        sfile << "\tmovq\t";
        sfile << toPrintRes << ", %rdx" << "\n";
        sfile << "\tmovl\t";
        sfile << toPrint1 << ", %eax" << "\n";
        sfile << "\tmovl\t%eax, (%rdx)" << "\n";
    }
    else if(q.op == PARAM) {
        int paramSize;
        DataType t;
        if(glb3 != NULL)
            t = glb3->type.type;
        else
            t = loc3->type.type;
        if(t == INT)
            paramSize = __INTEGER_SIZE;
        else if(t == CHAR)
            paramSize = __CHARACTER_SIZE;
        else
            paramSize = __POINTER_SIZE;
        stringstream ss;
        if(q.result[0] == '.')
            ss << "\tmovq\t$" << toPrintRes << ", %rax" <<"\n";
        else if(q.result[0] >= '0' && q.result[0] <= '9')
            ss << "\tmovq\t$" << q.result << ", %rax" <<"\n";
        else {
            if(loc3->type.type != ARRAY) {
                if(loc3->type.type != POINTER)
                    ss << "\tmovq\t" << toPrintRes << ", %rax" <<"\n";
                else if(loc3 == NULL)
                    ss << "\tleaq\t" << toPrintRes << ", %rax" <<"\n";
                else
                    ss << "\tmovq\t" << toPrintRes << ", %rax" <<"\n";
            }
            else {
                if(offRes < 0)
                    ss << "\tleaq\t" << toPrintRes << ", %rax" <<"\n";
                else {
                    ss << "\tmovq\t" << offRes << "(%rbp), %rdi" <<"\n";
                    ss << "\tmovq\t%rdi, %rax" <<"\n";
                }
            }
        }
        parameters.push(make_pair(ss.str(), paramSize));
    }
    else if(q.op == CALL) {
        int numParams = atoi(q.arg1.c_str());
        int totalSize = 0, k = 0;

        // We need different registers based on the parameters
        if(numParams > 6) {
            for(int i = 0; i < numParams - 6; i++) {
                string s = parameters.top().first;
                sfile << s << "\tpushq\t%rax" << "\n";
                totalSize += parameters.top().second;
                parameters.pop();
            }
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %r9d" << "\n";
            totalSize += parameters.top().second;
            parameters.pop();
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %r8d" << "\n";
            totalSize += parameters.top().second;				
            parameters.pop();
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rcx" << "\n";
            totalSize += parameters.top().second;
            parameters.pop();
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rdx" << "\n";
            totalSize += parameters.top().second;
            parameters.pop();
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rsi" << "\n";
            totalSize += parameters.top().second;
            parameters.pop();
            sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rdi" << "\n";
            totalSize += parameters.top().second;
            parameters.pop();
        }
        else {
            while(!parameters.empty()) {
                if(parameters.size() == 6) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %r9d" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
                else if(parameters.size() == 5) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %r8d" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
                else if(parameters.size() == 4) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rcx" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
                else if(parameters.size() == 3) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rdx" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
                else if(parameters.size() == 2) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rsi" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
                else if(parameters.size() == 1) {
                    sfile << parameters.top().first << "\tpushq\t%rax" << "\n" << "\tmovq\t%rax, %rdi" << "\n";
                    totalSize += parameters.top().second;
                    parameters.pop();
                }
            }
        }
        sfile << "\tcall\t" << q.result << "\n";
        if(q.arg2 != "")
            sfile << "\tmovq\t%rax, " << toPrint2 << "\n";
        sfile << "\taddq\t$" << totalSize << ", %rsp" << "\n";
    }
    else if(q.op == RETURN) {
        if(q.result != "")
            sfile << "\tmovq\t" << toPrintRes << ", %rax" << "\n";
        sfile << "\tleave" << "\n";
        sfile << "\tret" << "\n";
    }

}

// Main function which calls all other relevant functions for generating the target assembly code
void generateTargetCode(ofstream& sfile) {
    // Prints the global information to the assembly file
    auto it1 = globalST.symbols.begin();
    while(1) {
        if(it1 == globalST.symbols.end()) break;
        Sym* sym = *it1;
        if(sym->type.type == INT && sym->name[0] != 't') {
            if(sym->initVal == NULL) {
                sfile << "\t.comm\t";
                sfile << sym->name << ",4,4" << "\n";
            }
            else {
                sfile << "\t.globl\t";
                sfile << sym->name << "\n";
                sfile << "\t.data" << "\n";
                sfile << "\t.align\t4" << "\n";
                sfile << "\t.type\t";
                sfile << sym->name << ", @object" << "\n";
                sfile << "\t.size\t";
                sfile << sym->name << ", 4" << "\n";
                sfile << sym->name << ":" << "\n";
                sfile << "\t.long\t";
                sfile << sym->initVal->i << "\n";
            }
        }
        else if(sym->type.type == CHAR && sym->name[0] != 't') {
            if(sym->initVal == NULL) {
                sfile << "\t.comm\t";
                sfile << sym->name << ",1,1" << "\n";
            }
            else {
                sfile << "\t.globl\t";
                sfile << sym->name << "\n";
                sfile << "\t.data" << "\n";
                sfile << "\t.type\t";
                sfile << sym->name << ", @object" << "\n";
                sfile << "\t.size\t";
                sfile << sym->name << ", 1" << "\n";
                sfile << sym->name << ":" << "\n";
                sfile << "\t.byte\t";
                sfile << sym->initVal->c << "\n";
            }
        }
        it1++;
    }

    // Prints all the strings used in the program to the assembly file
    sfile << ".section\t.rodata" << "\n";
    int i = 0;
    auto it2 = stringConsts.begin();
    while(1) {
        if(it2 == stringConsts.end()) break;
        sfile << ".LC";
        sfile << i << ":" << "\n";
        i++;
        sfile << "\t.string " << *it2 << "\n";
        it2++;
    }
    Sym* currFunc = NULL;
    SymTab* currFuncTable = NULL;

    // Generates labels for different targets of goto statements
    i = 0;
    auto it3 = quadList.quads.begin();
    while(1) {
        if(it3 == quadList.quads.end()) break;
        if(it3->op != GOTO && (it3->op < GOTO_EQ || it3->op > IF_FALSE_GOTO));
        else {
            int target = atoi((it3->result.c_str()));
            if(labels.count(target));
            else {
                string labelName = ".L" + to_string(labelCount);
                labelCount++;
                labels[target] = labelName;
            }
            it3->result = labels[target];
        }
        it3++;
    }

    for(int i = 0; i < (int)quadList.quads.size(); i++) {
        // Print the Quad as a comment in the assembly file
        sfile << "# ";
        sfile << quadList.quads[i].print() << "\n";
        if(!labels.count(i));
        else sfile << labels[i] << ":" << "\n";

        // Necessary tasks for a function
        if(quadList.quads[i].op == FUNC_BEG) {
            i++;
            if(quadList.quads[i].op == FUNC_END) continue;
            else i--;
            currFunc = globalST.SearchGlob(quadList.quads[i].result);
            currFuncTable = currFunc->nestedTable;
            int memBind = 16;
            ST = currFuncTable;
            int takingParam = 1;
            int j = 0;
            while(1) {
                if(j >= currFuncTable->symbols.size()) break;
                if(currFuncTable->symbols[j]->name != "RETVAL") {
                    if(takingParam) {
                        currFuncTable->symbols[j]->offset = memBind;
                        memBind += 8;
                    }
                    else {
                        currFuncTable->symbols[j]->offset = memBind;
                        if(currFuncTable->symbols.size() > j + 1) memBind -= currFuncTable->symbols[j + 1]->size;
                    }
                }
                else {
                    takingParam = 0;
                    memBind = 0;
                    if(currFuncTable->symbols.size() > j + 1) memBind = -currFuncTable->symbols[j + 1]->size;
                }
                j++;
            }
            if(memBind < 0) memBind *= -1;
            else memBind = 0;
            funcRunning = quadList.quads[i].result;

            // Generates the function prologue to be printed before each function
            // Generic tasks like allocating space for variables on the stack are performed here
            int width = 16;
            sfile << "\n" << "\t.text" << "\n";
            sfile << "\t.globl\t";
            sfile << funcRunning << "\n";
            sfile << "\t.type\t";
            sfile << funcRunning << ", @function" << "\n";
            sfile << funcRunning << ":" << "\n";
            sfile << "\tpushq\t" << "%rbp" << "\n";
            sfile << "\tmovq\t" << "%rsp, %rbp" << "\n";
            sfile << "\tsubq\t$";
            sfile << (memBind / width + 1) * width << ", %rsp" << "\n";
        }
        // Function epilogue (while leaving a function)
        else if(quadList.quads[i].op == FUNC_END) {
            ST = &globalST;
            funcRunning = "";
            sfile << "\tleave" << "\n";
            sfile << "\tret" << "\n";
            sfile << "\t.size\t";
            sfile << quadList.quads[i].result << ", .-";
            sfile << quadList.quads[i].result << "\n";
        }
        if(funcRunning == "");
        else quadCode(quadList.quads[i], sfile);
    }
}

int main(int argc, char* argv[]) {
    ST = &globalST;
    yyparse();
    quadList.print();               // Print the three address quads
    ST->print("ST.global");         // Print the Sym tables

    // Generate the target assembly code
    ofstream sfile;
    sfile.open("A6_16_" + string(argv[argc - 1]) + ".s");
    ST = &globalST;
    generateTargetCode(sfile);
    sfile.close();
    return 0;
}